## 채널

채널은 **고루틴끼리 정보를 교환**하고 **실행의 흐름을 동기화**하기 위해 사용한다.

채널은 일반 변수를 선언하는 것과 독같이 선언하고, make() 함수로 생성한다. 채널을 정의할 때는 chan 키워드로 채널을 통해 주고받을 데이터의 타입을 지정해주어야 한다.

```go
// 채널 변수 선언 후 make() 함수로 채널 생성
var ch1 chan string
ch1 = make(chan string)

// make() 함수로 채널 생성 후 바로 변수에 할당
ch2 := make(chan bool)
```

채널을 정의할 때 **지정한 데이터 타입**만 채널을 통해 주고받을 수 있다. 타입에 상관없이 주고 받으려면 채털의 타입을 interface{}로 지정하면 된다.

<br>

채널로 값을 주고받을 때는 "<-" 연산자를 사용한다.

"<-" 연산자를 채널 변수 오른쪽에 작성하면 채널에 값을 전송하고, 왼쪽에 작성하면 채널로부터 값을 수신한다.

```go
ch<- "msg" // ch 채널에 "msg" 문자열 전송
m := <-ch  // ch 채널로부터 메시지 수신
```

채널에 값을 전달하거나 수신할 때 **채널이 준비되지 않으면 준비될 때까지 대기**한다. 채널이 비어 있지 않으면 전송되지 않고, 채널에 값이 들어오기 전에는 수신되지 않는다.

- - -

동시성을 처리할 때 sync패키지의 저수준 기능(Mutex, Lock)이 아니라, 채널을 사용한다해도 **교착상태 위험은 여전히 남아있다**. 

고루틴1은 고루틴2로부터 데이터를 받아 처리한 후 결과를 고루틴2로 보내고, 고루틴2도 데이터를 받아 처리한 다음 다시 고루틴1로 전달하는 상황이다. 여기서 두 고루틴은 교착상태에 빠질 수 있다.

Go는 교착상태와 경쟁상태를 테스트하기 위해 Race Detector를 제공한다. -race 플래그와 함께 Go 프로그램을 실행하면 경쟁상태를 확인해준다.

```
go run -race mysrc.go
```
- - -
<br>

### 포인터, 참조 전달

채널도 값에 의한 호출 방식으로 값을 전달한다. **실제 값이 복사되어 전달**되므로 bool, int, 배열 등의 값을 전달하는 것은 안전하다.

하지만 포인터 변수나 참조 값을 채널로 전달할 때는 **주소 값이 전달**되므로 값을 보내는 고루틴과 값을 받는 고루틴에서 **값을 동시에 수정**하면 예상치 못한 결과가 발생할 수 있다.

포인터나 참조 값을 채널로 전달할 때는 여러 고루틴에서 값을 동시에 수정하지 않게 해야 한다. 가장 간단한 방법은 여러 고루틴에서 참조 값에 동시에 접근할 수 없게 **뮤텍스로 제한**하는 것이다.

- - -
<br>

### 채널 방향

채널은 기본적으로 **양방향 통신이 가능한 상태**로 만들어진다. 하나의 채널로 값을 전송할 수도 있고 수신할 수도 있다. 

실제로는 채널을 **구조체의 필드**로 사용하거나 **함수의 매개변수**로 전달하는 것이 일반적인데, 이때는 채널이 **대부분 단방향**으로반 사용된다.

채널을 단방향으로 사용할 때는 반드시 방향을 지정해주는 것이 좋다. 코드를 작성할 때 에러를 통해 실수를 피할 수 있다.

```go
chan<- string // 송신 전용 채널
<-chan string // 수신 전용 채널
```

- - -
<br>

### 버퍼드 채널

채널은 **지정한 크기의 버퍼**를 가질 수 있다. 채널을 생성할 때 버퍼의 크기를 make의 두 번째 매개변수로 전달하면 버퍼드 채널을 만들 수 있다.

```go
ch := make(chan int, 100) 
```

버퍼드 채널은 **비동기 방식**으로 동작한다. 채널이 꽉 찰 때까지 채널로 메시지를 계속 전송할 수 있고, 채널이 빌 때까지 채널로부터 메시지를 계속 수신해 올 수 있다.

- - -

이 코드는 버퍼가 꽉 찼는데도 메시지를 계속 전송해서 에러가 발생한다.

```go
func main() {
    ch := make(chan int, 2)

    ch <- 1
    ch <- 2
    ch <- 3

    fmt.Println(<-ch)
    fmt.Println(<-ch)
    fmt.Println(<-ch)
}
```

- - -

채널에 세 번째 값을 전송하는 부분을 별도의 고루틴으로 동작시켰다. 고루틴은 채널에 값을 전송할 수 있을 때까지 대기하다가, 채널에 들어온 첫 번째 값을 수신해가는 즉시 바로 채널에 값을 전송한다.

```go
func main() {
    ch := make(chan int, 2)

    ch <- 1
    ch <- 2
    go func() { ch <- 3} ()

    fmt.Println(<-ch)
    fmt.Println(<-ch)
    fmt.Println(<-ch)
}
```

- - -
<br>

### close, range

채널에 더이상 전송할 값이 없으면 채널을 닫을 수 있다.

```go
close(ch)
```

채널을 닫은 후에 메시지를 전송하면 에러가 발생한다.

채널의 수신자는 채널에서 값을 읽을 때 채널이 닫힌 상태인지 아닌지 두 번째 매개변수로 확인할 수 있다.

```go
v, ok := <-ch
```

ok의 값이 false라면 채너렝 더는 수신할 값이 없고 채널이 닫힌 상태이다.


```go
for i := range ch {
    // body
}
```

이 코드는 채널 ch가 닫힐 때까지 반복하며 채널로부터 수신을 시도한다.

채널을 닫는 것은 필수가 아니다. 수신자가 채널에 **더 이상 들어올 값이 없다는 것을 알아야 할때만** 채널을 닫아준다. ex) range로 루프를 돌며 메시지를 수신할 때

- - -
<br>

### select

select 문은 **하나의 고루틴이 여러 채널과 통신할 때** 사용한다. case로 여러 채널을 대기시키고 있다가 실행 가능 상태가 된 채널이 있으면 해당 케이스를 수행한다.

```go
func fibonacci(ch, quit chan int) {
    x, y := 0, 1
    for {
        select {
        case ch <- x:
            x, y = y, x+y
        case <-quit:
            fmt.Println("quit")
            return
        }
    }
}

func main() {
    ch := make(chan int)
    quit := make(chan int)

    go func() { // 클로저 함수, ch, quit의 캡쳐값을 사용함
        for i := 0; i < 10; i++ {
            fmt.Println(<-c)
        }
        quit <- 0
    }()
    fibonacci(c, quit)
}
```

select 문에서 default 케이스를 지정하면 case에 지정된 모든 채널이 사용 가능 상태가 아닐 때 default 케이스를 수행한다.

default 케이스는 select 문에서 **case의 채널들이 사용 가능 상태가 아닐 경우**, 대기하지 않고 **바로 무언가를 처리해야 할 때** 사용한다.

```go
func main() {
    tick := time.Tick(100 * time.Millisecond)
    boom := time.After(500 * time.Millisecond)

    for {
        select {
        case <-tick:
            fmt.Println("tick. ")
        case <-boom:
            fmt.Println("BOOM! ")
            return
        default:
            fmt.Println(" .")
            time.Sleep(50 * time.Millisecond)
        }
    }
}
```